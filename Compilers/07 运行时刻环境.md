# 运行时刻环境

[TOC]

### 分配策略

+ 静态存储分配：为在编译时刻可以确定大小的数据对象分配存储空间
+ 动态存储分配：在编译时仅产生各种必要信息，在运行时刻动态分配数据对象的存储空间
  + 栈式存储分配
  + 堆式存储分配

### 运行时内存的划分

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20191213004029582.png" alt="image-20191213004029582" style="zoom: 50%;" />



+ 自底部向顶部：
  + 静态代码区  （底部）
  + 静态数据区
  + 栈区
    + 向顶部（下）拓展
    + 存储一种称为活动记录的数据结构，活动记录在过程调用时进栈，过程返回时出栈
  + 空闲内存
  + 堆区        （顶部）
    + 向底部（上）拓展
    + 管理用malloc()/free()的对象

### 活动记录

+ 定义
  + 使用过程（或函数、方法）作为用户自定义动作的单元的语言，编译器通常**以过程为单位分配存储空间**
  + 一个活动：过程体的每次执行
  + 过程每执行一次，就为它分配一块连续存储区，用来管理过程一次执行所需的信息，这块连续的存储区就成为活动记录
+ 一般形式（根据所使用的语言的不同而有差异）
  
  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20191213004115062.png" alt="image-20191213004115062" style="zoom:50%;" />
  
  + 实参
  + 返回值
  + 控制链
    + 指针
    + 指向调用者的活动记录
  + 访问链
    + 访问存在其他活动记录的**非局部数据**
  + 保存的机器状态
    + 返回地址，寄存器值
  + 局部数据
  + 临时变量

### 静态存储分配

+ 概述
  + 编译器为每个过程确定其活动记录在目标程序中的位置
  + 这样，过程中的每个名字的存储位置就确定了
  + 因此，这些名字的存储地址可以被编译到目标代码中
  + 过程每次执行时，他的名字都绑定到同样的存储单元
+ 限制条件
  + 数组上下界为常数
  + 不允许过程递归调用
    + 无法确定一个过程有多少个活动处于活跃状态（因为要给活跃的过程生成活动记录）
  + 不允许动态建立数据实体
+ 常用的静态存储分配方法
  + 顺序分配法
    + 按照过程出现的先后顺序逐段分配存储空间（各过程记录占用空间互不相交）
    + 优点：处理上简单
    + 缺点：对内存的使用不够经济合理
  + 层次分配法
    + 通过对过程间的调用关系进行分析，凡属无相互调用关系的**并列过程**，尽量使其局部数据**共享**存储空间 

### 栈式存储分配

+ 概述
  + 当一个过程被调用时，过程的活动记录被压入栈中；当过程结束时，该活动记录被弹出栈
  + 允许活跃时段不交叠的多个过程调用之间共享空间
  + 非局部变量的相对地址总是固定的，与过程调用序列无关
+ 活动树
  + 描述程序运行时控制进入和离开各个活动的情况的树
  + 每个结点对应一个活动，根节点为main过程的活动
  + 过程p的某个活动节点p1的子节点表示被活动p1调用的各个过程的活动，按照活动**被调用顺序**自左向右地显示它们，**一个子节点必须在其右兄弟节点开始活动前结束活动**
  + 每个活跃的活动都有一个位于控制栈中的活动记录

### 调用序列 返回序列

+ 调用者：

  + 将返回地址填到被调用者的栈帧
  + 将$sp旧址填到被调用者的栈帧
  + 修改$sp，指向被调用者栈帧**局部数据开始位置**

+ 被调用者：
  + 保存寄存器的值和其他状态
  + 初始化局部数据（load from memory）

  -----*以上为调用代码序列，以下为返回代码序列*-----

  + 或填写返回值
  + 恢复$sp到旧值，跳转到调用者之前填写的返回地址

  <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20191214154602745.png" alt="image-20191214154602745" style="zoom: 45%;" />

### 变长数据存储分配

+ 栈帧中只保存变长数组的指针
+ 将空间分配放在对应的活动记录之外

### 非局部数据的访问

+ 支持过程嵌套
  + 除自身定义的局部数据和全局定义的数据以外，还可以使用外围过程中声明的对象
  + 嵌套深度
    + 不内嵌在任何其它过程中的过程，设其嵌套深度为1
    + 如果一个过程p在一个嵌套深度为i的过程中定义，则设定p的嵌套深度为i+1
    + 变量嵌套深度=过程嵌套深度
  + 访问链
    + 静态作用域规则：只要过程b的声明嵌套在过程a的声明中，过程的声明中，过程b就可以访问过程a
    + 访问链的维护（直接调用过程）
      + 当嵌套深度为nx的过程x调用嵌套深度为ny过程y时: x->y
        + nx<ny（外层调用内层）
          + y必然在x中直接定义，y的访问链指向当前活动记录x（因为x只能调用在它自身中声明的过程）
        + nx=ny（本层调用本层）
          + 递归调用：y直接复制x的访问链
        + nx>ny（内层调用外层）
          + 过程x必定嵌套在某个过程z中，而z中直接定义过程y
            + <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20191214165225428.png" alt="image-20191214165225428" style="zoom: 80%;" />
            + 例如，p->e，p嵌套在过程s中，s直接定义过程e。沿着p的访问链，可以到达与e同一层的q的活动记录，e的访问链应该指向q的访问链所指向的活动记录
    + 访问链的维护（过程指针参数）
      + 传递过程指针作为参数时，除了传递参数的代码指针，还包括正确的访问链
  + 明确访问链，明确嵌套深度
    + 按照嵌套深度，对过程/函数名采取不一样的缩进，列成表，这样就很清晰
+ 不支持过程嵌套
  + **全局变量**被分配在**静态区**，使用静态确定的地址访问它们
  + 其它变量一定是**栈顶**活动的局部变量。可以通过运行时刻栈的top_sp指针访问它们

### 堆式存储分配

+  堆空间
   +  用于存放生命周期不确定、或者将生存到明确删除为止的数据对象
+  存储管理器
   +  分配和回收堆区空间的子系统
   +  分配：为内存请求分配一段连续、适合大小的堆空间
   +  回收：将被回收的空间返还到空闲空间的缓冲池
+  局部性
   +  时间局部性：一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问
   +  空间局部性：访问过的存储位置的邻近位置很可能在一个很短的时间段内被访问
+  堆空间分配
   +  best-fit
      +  将内存请求分配在满足请求的最小窗口（空闲存储块）中
      +  可以保留大窗口
   +  first-fit
      +  将内存请求分配在第一个能满足请求的窗口中
      +  花费时间少，但总体性能比best-fit差
+  人工存储管理
   +  内存泄漏：未能删除不能被引用的数据
   +  悬空指针引用：引用已被删除的数据

### 垃圾回收

+ 垃圾：不能被引用的数据
+ 解引用 (指针的 * 操作) 
  + 使用指针所指向变量，比如`int a=10; int *p=&a; cout<<*p<<endl;` 通过`*p`输出a的值就为解引用
+ 根集
  + 不需要对任何指针解引用就能被程序直接访问的数据
  + eg： java中所有静态字段成员和栈中的变量

+ 可达性
  + 根集成员都可达
  + 对任意一个对象，如果指向它的一个指针被保存在可达对象的某字段中、或数组元素中，那么这个对象也是可达的
  + **一旦某个对象变得不可达，就不可能再可达**
+ 改变可达对象的操作
  + 对象分配
    + 返回一个指向新存储块的引用
  + 参数传递/返回值
    + 对象引用从实在参数传递到形式参数
    + 从返回值传递给调用者
  + 引用赋值
    + `u=v；`v的引用被复制到u中，u中原来的引用丢失。可能使得u原来指向的对象（仅能通过u中引用到达的对象）变得不可达，并且递归地使得更多对象变得不可达
  + 过程返回
    + 活动记录出栈，局部变量消失，根集变小；可能使得一些对象变得不可达

+ 引用计数垃圾回收器
  + 每个对象有一个用于存放引用计数的字段，并按照如下方式维护
    + 对象分配：引用计数设为1
    + 参数传递：引用计数加1
    + 引用赋值：`u=v` u指向的对象引用减1，v指向的对象引用加1
    + 过程返回：局部变量指向对象的引用计数减1
    + 如果一个对象的引用计数为0，在删除对象之前，此对象中各个指针所指对象的引用计数减1
  + 缺陷：不能回收不可达的循环数据结构，会引起内存泄漏

### 基于跟踪的垃圾回收

+ 在 空闲空间耗尽 / 空闲空间数量低于阈值 时启动垃圾回收器
+ 标记-清扫式回收器
  + 一种直接的、全面停顿的算法
  + 分成两个阶段
    +  标记：从根集开始，跟踪并标记出所有可达对象；
    +  清扫：遍历整个堆区，释放不可达对象；

+ 基本抽象分类
  + 空闲
  + 未被访问
  + 待扫描
  + 已扫描
+ 标记-清扫式算法优化
  + 基本算法需要扫描整个堆
  + 优化
    + 用一个列表记录所有已分配的对象
    + 不可达对象 = 已分配对象 - 可达对象



> 未完 (



















