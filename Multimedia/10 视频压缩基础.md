# 视频压缩基础

[toc]

## 视频流码率计算

$$
\left[\frac{\text {长×宽×量化位数} \times \mathrm{fps}}{\text { 压缩率 }}\right]=\mathrm{bits} / \mathrm{sec}
$$
宽: pixels(160, 320, 640, 720, 1280, 1920, ..)
长: pixels(120, 240, 480, 485, 720, 1080, ..)
量化位数: bits $(1,4,8,15,16,24, \dots)$
fps: frames per second $(5,15,20,24,30, \dots)$ 压缩率: (1, 6, 24, ..)



## 运动补偿

+ *做差分编码/预测编码，使用的参考画面都是编码后再解码的出来的，不能直接用。因为参考画面原始值在解码器端不存在。*
+ 宏块的划分
  + 每个宏块16*16（含4个DCT块）（也因此水平垂直方向的分辨率必须是16的整数倍，否则补零）
  + 以宏块为单位，找出两帧画面中相应宏块之间的位移关系（运动矢量）
    + 每一个宏块在参考画面上找一个与其最相似的宏块。注意参考宏块不局限在将图片16*16分割后的小块中，可以是在图像任意位置的16\*16的块
  + 划分的是后一帧画面，前一帧画面（参考画面）不进行划分

+ 宏块的大小：16×16
  + 可预测宏块（与参考画面中某个宏块有位移关系）、不可位移宏块（找不到有位移关系）

+ 运动矢量的估计

  ![image-20200815235801080](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200815235801080.png)

  设定搜索范围（2p+1）。以宏块为中心划定一个搜索范围，在这个范围内搜索对应的宏块。到最佳匹配宏块的位移就被称为运动矢量，存储在输出码流中
  + 是否为最佳匹配：计算匹配度（均方误差MSE、平均绝对误差MAD）（公式看看就行）

    $M S E=\frac{1}{I \times J} \sum_{|x|<\frac{1}{2}}\sum_{|y|<\frac{1}{2}}\left[f(i, j)-g\left(i-d_{x}, j-d_{y}\right)\right]^{2}$
    $M A D=\frac{1}{I \times J} \sum_{|x|<\frac{1}{2}}\sum_{|y|<\frac{1}{2}}\left|f(i, j)-g\left(i-d_{x}, j-d_{y}\right)\right|$

  + 搜索策略（如何调整运动矢量）（计算量由大到小）

    + 全局搜索：计算在搜索范围内的每个像素位置对应的运动矢量，计算每个位置宏块的匹配度。复杂度：$(2p+1)·(2p+1)·N^2·3$（边长为2p+1的搜索范围内，边长为N的宏块，每次做3次浮点运算）

    + 对数搜索：每一步测试8个点，并逐步缩小搜索步长。

      复杂度：$\left(8 \cdot\left(\left\lceil\log _{2} p\right\rceil+1\right)+1\right) \cdot N^{2} \cdot 3$

    + 层次搜索：先向下采样2次（缩小为1/4），宏块也变成N/4*N/4了，在这个范围内全局采样后向上采样，在周围的8个点内找最优，再向上采样再找最优。

      复杂度：$\left.\left[\left(2 \mid \frac{P}{4}\right]+1\right)^{2}\left(\frac{N}{4}\right)^{2}+9\left(\frac{N}{2}\right)^{2}+9 N^{2}\right] \times 3$（因为向上采样后点值不一样了 所以要重新算一遍 所以是9）

      

## H.261视频编码

+ 视频的每一帧划分为两种：帧内帧（Intra-frames,I-frames）、帧间帧（Inter-frames，P-frames）
  + I帧只用自身画面内容进行编码
  + P帧要参考前面一帧（运动补偿）

+ H.261的量化
  + Jpeg量化：颜色分量，色度分量有量化表
  + H.261没有量化表，I帧的直流系数默认用8，其他系数可以用2*1~2\*31间的一个数

+ 编码流程
  + 第一帧， 进行DCT（量化），输出到码流。同时为了后面的帧可以预测，要进行逆DCT（逆量化），结果放在帧缓存里
  + 第二帧，根据帧缓存内容进行运动补偿（输入为P帧数据，帧缓存数据；输出为运动矢量）
  + 根据运动矢量生成16*16的预测画面，将该画面与原始画面中某一个宏块作差，对差值进行量化+逆量化



## H.263

半像素精度的运动补偿（261只能是整数）

不受限的运动矢量

基于符号的算数编码

增加PB帧（B帧同时参考前后两帧非B帧画面：效率下降+编码顺序受影响）

视频分辨率扩充到5种（261是种）





H系列更偏向实时性，用于视频会议等方向

