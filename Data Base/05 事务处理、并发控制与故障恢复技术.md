# 事务处理、并发控制与故障恢复技术

[TOC]

### 事务处理

+ 事务：用户执行的一个对数据库不可打断的操作系列
+ **事务的特性：ACID**
  + 原子性 A (atomicity): 同一事务中数据库的访问操作构成不可分割的操作序列
  + 一致性 C (consistency): 事务的成功执行是将数据库从一个一致的状态转换到另一个一致的状态
  + 隔离性 I (isolation): 事务之间相互独立
  + 持久性 D (durability): 事务对数据库的更新永远地反映在数据库中

+ 与事务有关的语句
  + 开始事务：`Begin transaction`
    + 关系数据库管理系统没有提供开始事务的控制语句，可以通过以下方式启动事务
      + 数据定义命令 DDL
      + 将系统设置为自动提交
      + 数据操纵命令 DML
  + 提交事务：`Commit transaction`
  + 回退事务：`Rollback transaction`
    + 事务执行的过程中，系统可以为事务设置若干检查点

+ 数据不一致现象：
  + 丢失修改：对多个事务未加控制地并发修改同一数据对象
    + 现象：一个事物的修改结果破坏了另一个事务的修改结果
    + 原因：对多个事务未加控制地并发修改同一数据对象
  + 脏读：读取了另一个事物未提交的修改结果（比如B读了A事务的中间数据）
    + 现象：读到了错误的数据
    + 原因：一个事物读取了另一个事物未提交的修改结果
  + 不可重复读：一个事物执行过程中，两次读取之间插入了另一个事务的写操作，导致两次读一个数据值不一样
    + 现象：一个事物执行过程中，前后两次读同一个数据得到的值不一致
    + 原因：两次读操作之间插入了另一个事物的写操作

### 事务并发执行

+ 一些概念
    + 可串行化调度
      + 一个调度A对数据库状态的影响与某个串行调度相同，则A是可串行化的
    + 冲突可串行化
      + 冲突等价：通过一系列相邻操作的非冲突交换可以将调度A转换为调度B，则调度A、B冲突等价
      + 一个调度S冲突等价于一个串行调度，则S冲突可串行化
+ 冲突的判断
    + 同一事物的任意两个操作不可交换它们的执行顺序
    + 不同事物的任意两个操作可以交换它们的执行顺序，除非
      + 它们涉及同一数据对象，并且至少其中一个为“写”操作
    + ”冲突可串行化“是“可串行化”的充分条件，不是必要条件

+ 优先图

  + 已知在调度S中存在事务A、B，如果A、B的一个动作x，y满足

    1. 在调度中x在y前
    2. x，y涉及数据库同一对象，且至少其中一个为“写”操作（x，y是冲突）

    则称A优先于B，记作A<B

  + 如果有事务A<B，在优先图中有A→B

  + 优先图构造TIPS：**找冲突**

  + 若优先图中存在环状结构，则该调度不是冲突可串行化的

### 封锁

+ 常用封锁类型

  + 排它锁(eXclusive lock, X锁)
    + A上了X锁就不能上其他锁了
    + 被事务T上了锁的数据A不能被其他事务访问，可以被T读/写
    + X锁必须维持到事务T的执行结束
    + 缺点：降低了系统的并行性
  + 共享锁(Share lock, S锁)
    + A没被上锁 或 只被上S锁，就还可以被事务T上S锁
    + 被T上S锁的A可以被T读，不能被T写
    + S锁不必维持到T的结束

+ 合适(Well formed)事务

  + 一个 访问数据A前申请对A封锁，操作结束后释放A上的封锁 的事务称为合适事务

+ 封锁协议

  + 何时申请封锁？申请哪种锁？何时释放？

  + 三级封锁协议

    + 一级封锁协议

      1. 事务T写数据A前要申请X锁，并维持到事务T的结束

      + 防止丢失修改

    + 二级封锁协议

      1. 一级封锁协议的要求
      2. 事务T读数据A前要申请S锁，读完后就可释放S锁

      + 防丢失修改+脏读

    + 三级封锁协议

      1. 一级封锁协议的要求
      2. 事务T读数据A前要申请S锁，并维持到事务T的结束

      + 防丢失修改+脏读+不可重复读

    + 小结

      <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20191229142327424.png" alt="image-20191229142327424" style="zoom:50%;" />

  + 两阶段封锁协议：2PL协议

    + 一个事务的执行过程中，必须把锁的申请与释放分为两个阶段
      1. 申请并获得封锁 		“扩展阶段”
      2. 释放所有申请的锁     “收缩阶段”
         + 一旦开始释放封锁，就不能再申请任何封锁（即所有封锁请求都先于所有的解锁请求）

  + 封锁使用规定
    + 一个事务对一个数据只能持有一把锁
    + 若事务T对同一数据对象A进行若干次封锁申请操作I1(A);I2(A);...In(A);后必须有且仅有一个ui(A)
    + 封锁的重复申请过程只能是：sli(A); ……; xli(A);
    + 对于事务i, j，xli(A)后面不能再有slj(A)或xlj(A)，除非中间有ui(A)

### 数据库恢复技术

+ 故障分类

  + 小型故障、中型故障、大型故障

+ 故障恢复三大技术

  + 转储：定期将数据库内容复制到其他存储设备

    + 动态、静态、海量、增量转储
    + 要结合日志信息

  + 日志：用于自动记载数据库中修改性操作的数据更新情况

    + 书写原则：先写日志，后改数据

    + 类型：

      + undo日志：用于被放弃事务的撤销

        + 记录格式：

          1. 开始事务：<Start T>
          2. 提交事务：<Commit T>
          3. 放弃事务：<Abort T>
          4. 更新记录：<T, X, V>
             + **V为旧值**
    + 记录规则：
    
      1. 修改数据库元素：修改前写日志到磁盘
          2. 提交事务：所有改动写到  磁盘后再写日志到磁盘
        + 恢复过程：
    1. 划分事务
             + 已提交事务：有<Start T>和<Commit T>
         + 未提交事务：有<Start T>无<Commit T>
          2. 反向扫描日志，对更新操作<T, X, V>：
         + 找到未提交的事务，将X的值改为V
          3. 直到事务开始标志，撤销操作结束
      4. 对未完成的事务T，在日志尾部写入<Abort T>并刷新日志
      + redo日志：用于已提交事务的重做（已更新的修改结果还在内存缓冲区还没有写到硬盘，由于故障使得内存缓冲区数据丢失，进行redo以恢复）
    + 记录格式：
          + 与undo日志一样，但是更新记录中**V为新值**
    + 记录规则：
    
          1. 修改前写日志到磁盘（包括更新记录跟提交记录）
        + 恢复过程：
          1. 确定所有已提交事务
      2. 正向扫描日志，对更新操作<T, X, V>：
             + T已提交，则为X写入新值V
         + T未提交，忽略
          3. 直到事务结束标志，重做操作结束
          4. 对未完成的事务T，在日志尾部写入<Abort T>并刷新日志
      + undo/redo日志：以上两种的合并
        + 记录格式：
          1. 更新记录：<T, X, v, w>
             + **v为旧值，w为新值**
        + 记录规则：
    
          1. 修改数据库元素：修改前写日志到磁盘
          2. 提交事务：所有改动写到  磁盘后再写日志到磁盘
          3. <Commit T>之后一定紧跟一条Flush log
        + 恢复过程：
          1. 从后往前undo
          2. 从前往后redo
    
    + 检查点 checkpoint
    
      1. 系统停止接受“启动新事务”请求
      2. 等当前所有活跃事务被提交/中止并将对应日志写入磁盘
      3. 写入<CKPT>，刷新日志到磁盘
      4. 开始接受新事务
    
      + 故障恢复时只用逆向扫瞄到第一条<CKPT>就可以结束故障恢复
    
    + 非静止检查点
    
    + undo，redo日志的区别
    
      1. 恢复目的不一样
      2. 交记录 <Commit T>与写入日志时间不一样
         + undo：数据库磁盘修改操作结束后才写入 <Commit T>到磁盘
         + redo：写入 <Commit T>到磁盘后才将更新后的值写入数据库
    
  + 数据库镜像
  
+ 故障恢复策略

  + 小型故障恢复
    + 未结束事务的undo操作恢复
  + 中型故障恢复
    + 非正常中止事务：undo
    + 已完成提交的事务：因为故障导致内存缓冲区数据未写入硬盘使得数据丢失，执行redo
    + 大型故障的回复：先利用后备副本进行数据库恢复，再用日志进行数据库恢复