## 关系数据库规范化理论

> 好的设计应该既具有合理的数据冗余度，又没有插入和删除等异常现象的出现

### 函数依赖
+ 关系r中任一元组t在X中属性值确定后，Y属性也确定，则称Y函数依赖于X函数。记作X->Y
+ 关系r中任取两元组t1,t2，如果t1[x]=t2[x],则与t1[y]=t2[y]

+ 平凡/非平凡函数依赖
  + 对函数依赖关系X->Y，若Y∉X，则该函数依赖是非平凡的函数依赖，否则为平凡函数依赖
+ 完全函数依赖
  + 在关系模式R(U)中，若有X、Y⊆U，且对于X的任何真子集X'都有**X'!->Y**，则Y完全函数依赖于X，记作X-f->Y
  + ![img](https://pic2.zhimg.com/80/12513de20079d12b99d946072df7311a_hd.jpg)
  + 在关系模式R(U)中，若有X、Y⊆U，且存在X的真子集X'有**X'->Y**，则Y部分函数依赖于X记作X-p->Y
+ 传递函数依赖
  + 在关系模式R(U)中，若有X、Y、Z⊆U，且存在函数依赖X->Y，Y∉X，Y!->X，Y->Z，则Z传递依赖于X
  
### Armstrong公理
  + 自反规则：如果Y是X的子集，则Y->X
  + 增广规则：如果X->Y，则XZ->YZ
  + 传递规则：如果X->Y，Y->Z，则X->Z
  + 分解规则：如果X->YZ，X->Y
  + 合并规则：X->Y && X->Z，X->YZ
  + 伪传递规则：X->Y && WY->Z，WX->Z

### 函数依赖集的闭包:
  + 设F是关系模式R(U)的一个函数依赖集，X,Y是关系模式R的属性子集，如果从F中的已有函数依赖关系利用Armstrong公理可以推出X->Y，则称F逻辑蕴涵X->Y
  + 被F逻辑蕴含的所有函数依赖关系构成的集合称为F的闭包，记作F+

### 属性集的闭包X+ / Xf+
  + F是是关系模式R(U)的函数依赖集，X是关系模式R(U)的属性子集，由所有函数依赖于X的属性构成的属性集合，称为X在函数依赖集F上的闭包
  + Algorithm 8-1: 计算属性集X在函数依赖集F上的闭包X+：
    ```
    X+ := X;
    repeat
        oldX+ := X+ ;
        for each functional dependency Y -> Z in F do
            if Y ⊆ X+ then X+ := X+ ∪ Z;
    until ( oldX+ = X+  )
    ```
    
### 关键字
+ 关键字：关系模式R(U,F)中，全集**U**完全依赖于K，则K为R的关键字
  + 对K的任意一个真子集Z都有：Z+ != U (可用于对关键字进行检验)
  + 除主关键字之外的其他关键字称为候选关键字
+ 主属性集：所有关键字中的属性
+ 非主属性集：主属性及之外的属性所构成的集合
+ 如何找关系模式R(U,F)中的关键字
  + 用Armstrong公理，从已知的函数依赖集中推导出完全函数依赖关系K->U
  + 计算满足K+=U的最小属性集合K
  + 计算函数依赖集F的最小覆盖（与F等价的最小函数依赖集），然后根据函数依赖特性和关键字定义来找
+ Algorithm 8-2:寻找关系模式R(U,F)的关键字K
  ```
    set K := U ;
    for each attribute A in K
    {
        compute (K–A)+ ;
        if (K–A)+ contains all the attributes in R, then
        {
            set K := K – {A} ;
        }
    }
  ```
+ 可以将属性分为三个部分：
+ 只在函数依赖左边出现过的属性集合U1，只在右边出现的U2，都出现过的U3
+ U1是关键字的组成部分
+ U2不可能出现在关键字中
+ 只用在U3中进行for循环就行

### 判断函数依赖集是否等价
检查两个函数依赖集是否相符逻辑蕴涵
例：F与G两个函数依赖集
1. 判断F中的函数依赖是否为G所逻辑蕴涵
   + 对于F中的每个函数依赖X->A做如下判断：若A∈X的属性集闭包X+，则G逻辑蕴涵X->A
2. 判断G中的函数依赖是否为F所逻辑蕴涵
   + 对于F中的每个函数依赖Y->B做如下判断：若B∈Y的属性集闭包Y+，则G逻辑蕴涵Y->B 
3. 若F、G相互逻辑蕴涵则等价

### 最小函数依赖集判定条件
+ 最小函数依赖集定义：与函数依赖集F相等价的所有函数依赖集中最小者
+ 又称为最小覆盖
+ 不具有唯一性
 + 满足下述三个条件，对于F中的每一个FD关系X—>A均作如下判断:
  1. 依赖因素A为单个属性；（不是必须的，只是为了方便判断，可以通过分解规则得到）
  2. 令：F1=F - {X—>A}，则 F1+!=F+;
     - 不存在冗余的函数依赖关系
  3. 对于决定因素 X 的每一个真子集Y (Y属于X) 均作如下判断：令 F2 =  F - {X—>A}∪{Y—>A}，则F2+!=F+
     - 不存在部分函数依赖关系
+ **计算F的最小依赖集**
  + 使用Armstrong公理的分解规则分解函数依赖为单属性的函数依赖
  + 检查部分依赖：在左边的决定因素里检查每个元素是不是多余的
    + 在左边大于2个决定因子的函数依赖中，一个一个去掉左边的决定因子试试看，检查是否多余
    + **在去掉因子之前的函数依赖中**看去掉后左边部分的属性集闭包是否含右边，含则去掉的因子多余
  + 检查冗余：依次去掉每个函数依赖看看
    + 比如：F1去掉f: A->C后得到F2，检查F2中是否蕴涵f
      1. 看F2的**A+**属性集闭包中有没有依赖因素C
      2. 通过Armstrong公理看能不能推出来



### 与函数依赖有关的范式
> 可以类比“类”与“对象”，“关系”是“关系模式”的一个实例，可以把关系理解为一张带数据的表，关系模式是这张表的数据结构
+ 第一范式：1NF
  + 如果关系模式R(U)的每个属性值都不可分割，则称该关系模式满足第一范式，R∈1NF
+ 第二范式：2NF
  + 设关系模式R(U)∈1NF，且每个非主属性都完全依赖于关键字，则称R(U)满足第二范式，R(U)∈2NF
  + 第二范式（2NF）就是非主属性完全依赖于主关键字
  + 判断是否符合2NF：
    + 找出数据表中的所有候选键（建议直接列出来）
    + 找出数据表中的所有主属性
    + 主属性剩下的就是非主属性
    + 查看是否存在非主属性对关键字的部分依赖
+ 第三范式：3NF
  + 设关系模式R(U)∈2NF，且每个非主属性都不传递函数依赖于关键字，则称关系模式R(U)满足第三范式，R(U)∈3NF
  + 第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
  + <font color=red>例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。<font color=black>
+ BCNF
  + 设关系模式R(U)∈1NF，且若X->Y时X必包含有该关键模式的关键字，则称关系模式满足BCN

+ 仅满足第一范式会带来的问题
  + 数据冗余（存在非主属性对关键字的部分函数依赖）
  
### 模式分解：
  + 选择一个不符合要求的函数依赖关系作如下的分解：
  + 假设X-f->Y∈F+且不满足范式M的要求，则将关系模式R分解为R1、R2 
    R1(X∪Y,{X->Y})   
    R2(Head(R)-Y , F2)，其中
    F2={A->B | A->B∈F+ && (A∪B)⊆Head(R2)}
  + 分解过程
    + 找出不满足范式要求的函数依赖
    + 将不满足条件的依赖一一进行模式分解
    + 合并关键字相同的子关系模式
 
### 多值依赖
+ 多值依赖MVD：
  + 设有关系模式R(U)，X,Y是U的子集（X,Y⊆U），若对R(U)的任何一个关系r，对X的一个确定值存在Y的一值与之对应，且Y的这组值又与Z=U-X-Y中的属性值不相关，此时称Y多值依赖于X，记作X->->Y
  + 存在两个互相独立属性之间的“一对多”函数关系
+ 非平凡的多值依赖：
  + 设在关系模式R(U)中，X->->Y且U-X-Y！=∅，则X->->Y为非平凡的多值依赖
+ 多值依赖的性质
  + 若X->->Y，则X->->(U-X-Y)
  + 若X->Y，则X->->Y

### 第四范式
+ 定义：
  + 在关系模式R(U)中，如果X->->Y是非平凡多值依赖，且X含有关键字，则R∈4NF
+ 特点：
  + 只允许出现平凡多值依赖
  + 满足BCNF
  